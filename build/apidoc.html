<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/nathanoehlman/knox-mpu#readme"

    >knox-mpu (v0.1.6)</a>
</h1>
<h4>Provide multi part upload functionality to Amazon S3 using the knox library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.knox-mpu">module knox-mpu</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.knox-mpu">
            function <span class="apidocSignatureSpan"></span>knox-mpu
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload">
            function <span class="apidocSignatureSpan">knox-mpu.</span>multipartupload
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.super_">
            function <span class="apidocSignatureSpan">knox-mpu.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knox-mpu.</span>multipartupload.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knox-mpu.</span>parse</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knox-mpu.multipartupload">module knox-mpu.multipartupload</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.multipartupload">
            function <span class="apidocSignatureSpan">knox-mpu.</span>multipartupload
            <span class="apidocSignatureSpan">(opts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.super_">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knox-mpu.multipartupload.prototype">module knox-mpu.multipartupload.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._abortUploads">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_abortUploads
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._completeUploads">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_completeUploads
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._handleStream">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_handleStream
            <span class="apidocSignatureSpan">(stream, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._initiate">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_initiate
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._putFile">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_putFile
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._putStream">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_putStream
            <span class="apidocSignatureSpan">(stream, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.multipartupload.prototype._uploadPart">
            function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_uploadPart
            <span class="apidocSignatureSpan">(part, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knox-mpu.parse">module knox-mpu.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knox-mpu.parse.xmlResponse">
            function <span class="apidocSignatureSpan">knox-mpu.parse.</span>xmlResponse
            <span class="apidocSignatureSpan">(req, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knox-mpu" id="apidoc.module.knox-mpu">module knox-mpu</a></h1>


    <h2>
        <a href="#apidoc.element.knox-mpu.knox-mpu" id="apidoc.element.knox-mpu.knox-mpu">
        function <span class="apidocSignatureSpan"></span>knox-mpu
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiPartUpload(opts, callback) {
    if (!opts.client || !opts.objectName) {
        throw new Error(&#x27;MultiPart upload must be created from a client and provide an object name&#x27;);
    }

    if (!opts.stream &#x26;&#x26; !opts.file) {
        throw new Error(&#x27;MultiPart upload must be passed either a stream or file parameter&#x27;);
    }

    if (opts.stream &#x26;&#x26; opts.file) {
        throw new Error(&#x27;You cannot provide both a stream and a file to upload&#x27;);
    }

    if (opts.noDisk &#x26;&#x26; opts.partSize &#x26;&#x26; opts.partSize &#x3e; 10485760) {
        throw new Error(&#x27;Keep in-memory part sizes 10MB or less&#x27;);
    }

    callback = callback || function(err, results) {};

    this.objectName = opts.objectName;
    this.fileName = opts.file;
    this.headers = opts.headers || {};
    this.client = opts.client;
    this.partSize = opts.partSize || 5242880; // 5MB default
    this.maxRetries = opts.maxRetries || 0;   // default to no retry
    this.uploadId = null;
    this.uploads = new Batch();
    this.noDisk = opts.noDisk;
    this.maxUploadSize = opts.maxUploadSize || 1/0; // infinity default
    this.currentUploadSize = 0;
    this.aborted = false;
    this.totalUploadSize = 0;

    this.uploads.concurrency(opts.batchSize ||4); // 4 simultaneous uploads by default

    // initialise the tmp directory based on opts (fallback to os.tmpDir())
    this.tmpDir = !this.noDisk &#x26;&#x26; (opts.tmpDir || os.tmpDir());

    var mpu = this,
        written = 0;

    mpu.on(&#x27;partProgress&#x27;, function(data) {
        written += data.written;
        mpu.emit(&#x27;progress&#x27;, {
            written: written,
            total: mpu.totalUploadSize,
            percent: written / mpu.totalUploadSize * 100 | 0
        });
    });

    // Recalculate progress as previously written data needs to be rewritten
    mpu.on(&#x27;failed&#x27;, function(part, partWritten) {
        written = written - partWritten;
    });

    if (opts.stream) {
        this._putStream(opts.stream, callback);
    } else {
        this._putFile(opts.file, callback);
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload" id="apidoc.element.knox-mpu.multipartupload">
        function <span class="apidocSignatureSpan">knox-mpu.</span>multipartupload
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiPartUpload(opts, callback) {
    if (!opts.client || !opts.objectName) {
        throw new Error(&#x27;MultiPart upload must be created from a client and provide an object name&#x27;);
    }

    if (!opts.stream &#x26;&#x26; !opts.file) {
        throw new Error(&#x27;MultiPart upload must be passed either a stream or file parameter&#x27;);
    }

    if (opts.stream &#x26;&#x26; opts.file) {
        throw new Error(&#x27;You cannot provide both a stream and a file to upload&#x27;);
    }

    if (opts.noDisk &#x26;&#x26; opts.partSize &#x26;&#x26; opts.partSize &#x3e; 10485760) {
        throw new Error(&#x27;Keep in-memory part sizes 10MB or less&#x27;);
    }

    callback = callback || function(err, results) {};

    this.objectName = opts.objectName;
    this.fileName = opts.file;
    this.headers = opts.headers || {};
    this.client = opts.client;
    this.partSize = opts.partSize || 5242880; // 5MB default
    this.maxRetries = opts.maxRetries || 0;   // default to no retry
    this.uploadId = null;
    this.uploads = new Batch();
    this.noDisk = opts.noDisk;
    this.maxUploadSize = opts.maxUploadSize || 1/0; // infinity default
    this.currentUploadSize = 0;
    this.aborted = false;
    this.totalUploadSize = 0;

    this.uploads.concurrency(opts.batchSize ||4); // 4 simultaneous uploads by default

    // initialise the tmp directory based on opts (fallback to os.tmpDir())
    this.tmpDir = !this.noDisk &#x26;&#x26; (opts.tmpDir || os.tmpDir());

    var mpu = this,
        written = 0;

    mpu.on(&#x27;partProgress&#x27;, function(data) {
        written += data.written;
        mpu.emit(&#x27;progress&#x27;, {
            written: written,
            total: mpu.totalUploadSize,
            percent: written / mpu.totalUploadSize * 100 | 0
        });
    });

    // Recalculate progress as previously written data needs to be rewritten
    mpu.on(&#x27;failed&#x27;, function(part, partWritten) {
        written = written - partWritten;
    });

    if (opts.stream) {
        this._putStream(opts.stream, callback);
    } else {
        this._putFile(opts.file, callback);
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.super_" id="apidoc.element.knox-mpu.super_">
        function <span class="apidocSignatureSpan">knox-mpu.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knox-mpu.multipartupload" id="apidoc.module.knox-mpu.multipartupload">module knox-mpu.multipartupload</a></h1>


    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.multipartupload" id="apidoc.element.knox-mpu.multipartupload.multipartupload">
        function <span class="apidocSignatureSpan">knox-mpu.</span>multipartupload
        <span class="apidocSignatureSpan">(opts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiPartUpload(opts, callback) {
    if (!opts.client || !opts.objectName) {
        throw new Error(&#x27;MultiPart upload must be created from a client and provide an object name&#x27;);
    }

    if (!opts.stream &#x26;&#x26; !opts.file) {
        throw new Error(&#x27;MultiPart upload must be passed either a stream or file parameter&#x27;);
    }

    if (opts.stream &#x26;&#x26; opts.file) {
        throw new Error(&#x27;You cannot provide both a stream and a file to upload&#x27;);
    }

    if (opts.noDisk &#x26;&#x26; opts.partSize &#x26;&#x26; opts.partSize &#x3e; 10485760) {
        throw new Error(&#x27;Keep in-memory part sizes 10MB or less&#x27;);
    }

    callback = callback || function(err, results) {};

    this.objectName = opts.objectName;
    this.fileName = opts.file;
    this.headers = opts.headers || {};
    this.client = opts.client;
    this.partSize = opts.partSize || 5242880; // 5MB default
    this.maxRetries = opts.maxRetries || 0;   // default to no retry
    this.uploadId = null;
    this.uploads = new Batch();
    this.noDisk = opts.noDisk;
    this.maxUploadSize = opts.maxUploadSize || 1/0; // infinity default
    this.currentUploadSize = 0;
    this.aborted = false;
    this.totalUploadSize = 0;

    this.uploads.concurrency(opts.batchSize ||4); // 4 simultaneous uploads by default

    // initialise the tmp directory based on opts (fallback to os.tmpDir())
    this.tmpDir = !this.noDisk &#x26;&#x26; (opts.tmpDir || os.tmpDir());

    var mpu = this,
        written = 0;

    mpu.on(&#x27;partProgress&#x27;, function(data) {
        written += data.written;
        mpu.emit(&#x27;progress&#x27;, {
            written: written,
            total: mpu.totalUploadSize,
            percent: written / mpu.totalUploadSize * 100 | 0
        });
    });

    // Recalculate progress as previously written data needs to be rewritten
    mpu.on(&#x27;failed&#x27;, function(part, partWritten) {
        written = written - partWritten;
    });

    if (opts.stream) {
        this._putStream(opts.stream, callback);
    } else {
        this._putFile(opts.file, callback);
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.super_" id="apidoc.element.knox-mpu.multipartupload.super_">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knox-mpu.multipartupload.prototype" id="apidoc.module.knox-mpu.multipartupload.prototype">module knox-mpu.multipartupload.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._abortUploads" id="apidoc.element.knox-mpu.multipartupload.prototype._abortUploads">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_abortUploads
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_abortUploads = function (callback) {

    var mpu = this;

    this.uploads.end(function(err, results) {

        if (err) return callback(err);

        var req = mpu.client.request(&#x27;DELETE&#x27;, mpu.objectName + &#x27;?uploadId=&#x27; + mpu.uploadId);

        // Register the response handler
        parse.xmlResponse(req, function(err, body) {
            if (err) return callback(err);
            return callback(&#x27;reached maxUploadSize&#x27;);
        });

        req.end();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._completeUploads" id="apidoc.element.knox-mpu.multipartupload.prototype._completeUploads">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_completeUploads
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_completeUploads = function (callback) {

    var mpu = this;

    this.uploads.end(function(err, results) {

        if (err) return callback(err);

        var size = 0, parts;
        parts = _.map(results, function(value) {
            size += value.size;
            return util.format(&#x27;&#x3c;Part&#x3e;&#x3c;PartNumber&#x3e;%d&#x3c;/PartNumber&#x3e;&#x3c;ETag&#x3e;%s&#x3c;/ETag&#x3e;&#x3c;/Part&#x3e;&#x27;, value.part, value.etag);
        }).join(&#x27;&#x27;);

        var req = mpu.client.request(&#x27;POST&#x27;, mpu.objectName + &#x27;?uploadId=&#x27; + mpu.uploadId);

        // Register the response handler
        parse.xmlResponse(req, function(err, body) {
            if (err) return callback(err);
            delete body.$;
            body.size = size;
            mpu.emit(&#x27;completed&#x27;, body);
            return callback(null, body);
        });

        // Write the request
        req.write(&#x27;&#x3c;CompleteMultipartUpload&#x3e;&#x27; + parts + &#x27;&#x3c;/CompleteMultipartUpload&#x3e;&#x27;);
        req.end();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._handleStream" id="apidoc.element.knox-mpu.multipartupload.prototype._handleStream">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_handleStream
        <span class="apidocSignatureSpan">(stream, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleStream = function (stream, callback) {

    var mpu = this,
        parts = [],
        current;

    // Create a new part
    function newPart() {
        var partId = parts.length + 1,
            partFileName = path.resolve(path.join(mpu.tmpDir || &#x27;&#x27;, &#x27;mpu-&#x27; + this.objectName + &#x27;-&#x27; + random_seed() + &#x27;-&#x27; + (mpu.
uploadId || Date.now()) + &#x27;-&#x27; + partId)),
            partFile = !mpu.noDisk &#x26;&#x26; fs.createWriteStream(partFileName),
            part = {
                id: partId,
                stream: partFile,
                fileName: partFileName,
                offset: 0,
                length: 0,
                triesLeft: mpu.maxRetries + 1,
                data: Buffer(&#x27;&#x27;)
            };

        parts.push(part);
        return part;
    }

    function partReady(part) {
        if (!part) return;

        // Ensure the stream is closed
        if (part.stream &#x26;&#x26; part.stream.writable) {
            part.stream.end();
        }
        mpu.uploads.push(mpu._uploadPart.bind(mpu, part));
    }

    function abortUpload(part) {
        // Ensure the stream is closed and temporary file removed
        if (part &#x26;&#x26; part.stream.writable) {
            // Ensure the stream is closed
            if (part.stream.writable) {
                part.stream.end();
            }

            // Remove the temporary file
            fs.unlink(part.fileName, function(err) {
                if(err) return callback(err);
            });
        }

        current = null;
        mpu.aborted = true;
    }

    // Handle the data coming in
    stream.on(&#x27;data&#x27;, function(buffer) {
        // Check if we are over the max total limit
        if((mpu.currentUploadSize += buffer.length )&#x3e; mpu.maxUploadSize){
            return abortUpload(current);
        }

        if (!current) {
            current = newPart();
        }

        if (current.stream) {
            current.stream.write(buffer);
        } else {
            current.data = Buffer.concat([current.data, buffer]);
        }
        current.length += buffer.length;
        mpu.totalUploadSize += buffer.length;

        // Check if we have a part
        if (current.length &#x3e;= mpu.partSize) {
            partReady(current);
            current = null;
        }
    });

    // Handle the end of the stream
    stream.on(&#x27;end&#x27;, function() {
        if (current) {
            partReady(current);
        }

        // Wait for the completion of the uploads
        if(mpu.aborted){
          return mpu._abortUploads(callback);
        }else{
          return mpu._completeUploads(callback);
        }
    });

    // Handle errors
    stream.on(&#x27;error&#x27;, function(err) {
        // Clean up
        return callback(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._initiate" id="apidoc.element.knox-mpu.multipartupload.prototype._initiate">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_initiate
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initiate = function (callback) {
    // Send the initiate request
    var req = this.client.request(&#x27;POST&#x27;, this.objectName + &#x27;?uploads&#x27;, this.headers),
        mpu = this;

    // Handle the xml response
    parse.xmlResponse(req, function(err, body) {

        if (err) return callback(err);
        if (!body.UploadId) return callback(&#x27;Invalid upload ID&#x27;);

        mpu.uploadId = body.UploadId;
        mpu.emit(&#x27;initiated&#x27;, body.UploadId);
        return callback(null, body.UploadId);
    });

    req.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._putFile" id="apidoc.element.knox-mpu.multipartupload.prototype._putFile">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_putFile
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_putFile = function (file, callback) {
    if (!file) return callback(&#x27;Invalid file&#x27;);

    var mpu = this,
        parts = [];

    fs.exists(file, function(exists) {
        if (!exists) {
            return callback(&#x27;File does not exist&#x27;);
        }

        fs.lstat(file, function (err, stats) {
            var remainingBytes = stats.size;
            var offset = 0;
            mpu.totalUploadSize = stats.size;
            while (remainingBytes &#x3e; mpu.partSize) {
                var partId = parts.length + 1,
                    part = {
                        id: partId,
                        fileName: mpu.fileName,
                        offset: offset,
                        length: mpu.partSize,
                        triesLeft: mpu.maxRetries + 1
                    };
                offset += mpu.partSize;
                remainingBytes -= mpu.partSize;
                parts.push(part);
                mpu.uploads.push(mpu._uploadPart.bind(mpu, part));
            }
            if (remainingBytes) {
                var partId = parts.length + 1,
                    part = {
                        id: partId,
                        fileName: mpu.fileName,
                        offset: offset,
                        length: remainingBytes,
                        triesLeft: mpu.maxRetries + 1
                    };
                parts.push(part);
                mpu.uploads.push(mpu._uploadPart.bind(mpu, part));
            }

            mpu._initiate(function(err, uploadId) {
                if (err || !uploadId) {
                    return callback(&#x27;Unable to initiate file upload&#x27;);
                }
                return mpu._completeUploads(callback);
            });
        });
   });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._putStream" id="apidoc.element.knox-mpu.multipartupload.prototype._putStream">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_putStream
        <span class="apidocSignatureSpan">(stream, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_putStream = function (stream, callback) {

    if (!stream) return callback(&#x27;Invalid stream&#x27;);

    var mpu = this;

    if (!this.uploadId) {
        this._initiate(function(err, uploadId) {
            if (err || !uploadId) return callback(&#x27;Unable to initiate stream upload [&#x27; + err || &#x27;No upload ID&#x27; + &#x27;]&#x27;);
        });
    }
    // Start handling the stream straight away
    mpu._handleStream(stream, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knox-mpu.multipartupload.prototype._uploadPart" id="apidoc.element.knox-mpu.multipartupload.prototype._uploadPart">
        function <span class="apidocSignatureSpan">knox-mpu.multipartupload.prototype.</span>_uploadPart
        <span class="apidocSignatureSpan">(part, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_uploadPart = function (part, callback) {

    // If we haven&#x27;t started the upload yet, wait for the initialization
    if (!this.uploadId) {
        return this.on(&#x27;initiated&#x27;, this._uploadPart.bind(this, part, callback));
    }

    var url = this.objectName + &#x27;?partNumber=&#x27; + part.id + &#x27;&#x26;uploadId=&#x27; + this.uploadId,
        headers = { &#x27;Content-Length&#x27;: part.length },
        req = this.client.request(&#x27;PUT&#x27;, url, headers),
        partStream = !this.noDisk &#x26;&#x26; fs.createReadStream(part.fileName, {start: part.offset, end: part.offset + part.length - 1}),
        mpu = this,
        written = 0;

    // Wait for the upload to complete
    req.on(&#x27;response&#x27;, function(res) {
        if (res.statusCode != 200) {
            var result = {part: part.id, message: &#x27;Upload failed with status code &#x27;+res.statusCode };
            mpu.emit(&#x27;failed&#x27;, result);
            if (--part.triesLeft)
                return MultiPartUpload.prototype._uploadPart.call(mpu, part, callback);
            else
                return callback(result);
        }

        // Grab the etag and return it
        var etag = res.headers.etag,
            result = {part: part.id, etag: etag, size: part.length};

        mpu.emit(&#x27;uploaded&#x27;, result);
        return callback(null, result);
    });

    // Handle errors
    req.on(&#x27;error&#x27;, function(err) {
        var result = {part: part.id, message: err};
        mpu.emit(&#x27;failed&#x27;, result, written);
        if (--part.triesLeft)
            return MultiPartUpload.prototype._uploadPart.call(mpu, part, callback);
        else
            return callback(result);
    });

    if (!this.noDisk) {
        partStream.on(&#x27;data&#x27;, function (data) {
            written += data.length;
            mpu.emit(&#x27;partProgress&#x27;, {
                part: part.id,
                written: data.length,
                overall: written,
                total: part.length,
                percent: written / part.length * 100 | 0
            });
        });
        partStream.pipe(req);
    } else {
        req.write(part.data);
        req.end();
    }

    mpu.emit(&#x27;uploading&#x27;, part.id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knox-mpu.parse" id="apidoc.module.knox-mpu.parse">module knox-mpu.parse</a></h1>


    <h2>
        <a href="#apidoc.element.knox-mpu.parse.xmlResponse" id="apidoc.element.knox-mpu.parse.xmlResponse">
        function <span class="apidocSignatureSpan">knox-mpu.parse.</span>xmlResponse
        <span class="apidocSignatureSpan">(req, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xmlResponse(req, callback) {

    if (!req) return callback(&#x27;Invalid request&#x27;);

    // Handle the response
    req.on(&#x27;response&#x27;, function(res) {
        var body = &#x27;&#x27;;

        res.on(&#x27;data&#x27;, function(chunk){
            body += chunk;
        });

        res.on(&#x27;end&#x27;, function(){
            var parser = new xml2js.Parser({explicitArray: false, explicitRoot: false});
            parser.parseString(body, callback);
        });

        res.on(&#x27;error&#x27;, callback);
    });

    req.on(&#x27;error&#x27;, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
